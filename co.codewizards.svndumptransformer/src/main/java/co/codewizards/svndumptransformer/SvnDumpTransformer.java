package co.codewizards.svndumptransformer;

import static co.codewizards.svndumptransformer.Util.*;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Utility transforming an SVN dump file - replacing contents.
 * @author Marco หงุ่ยตระกูล-Schulze - marco at codewizards dot co
 */
public class SvnDumpTransformer {

	private static final int MEBIBYTE = 1024 * 1024;

	private File inputFile;
	private File outputFile;
	private ExtDataInputStream in;
	private ExtDataOutputStream out;

	private final Map<String, String> replacementMap = new LinkedHashMap<>();

	public static void main(String[] args) throws Exception {
		if (args.length == 0) {
			System.out.println("SvnDumpTransformer INPUTFILE OUTPUTFILE REPLACEMENTS");
			System.out.println();
			System.out.println("INPUTFILE - path to the input file (generated by 'svnadmin dump').");
			System.out.println();
			System.out.println("OUTPUTFILE - path to the output file (can be imported by 'svnadmin load').");
			System.out.println();
			System.out.println("REPLACEMENTS - pairs of replacement map entries. Every 1st value is replaced by every 2nd value.");
			System.out.println();
			System.out.println();
			System.out.println("Example:");
			System.out.println("  SvnDumpTransformer oldproduct.svndump newproduct.svndump OldProduct NewProduct oldProduct newProduct \"old product\" \"new product\"");
			return;
		}

		if (args.length < 2) {
			System.err.println("INPUTFILE and OUTPUTFILE are both required!");
			System.exit(1);
		}

		if ((args.length - 2) % 2 != 0) {
			System.err.println("REPLACEMENTS is not an even number of values (must be key-value-pairs)!");
			System.exit(2);
		}

		File inputFile = new File(args[0]);
		File outputFile = new File(args[1]);
		SvnDumpTransformer svnDumpTransformer = new SvnDumpTransformer(inputFile, outputFile);

		for (int i = 2; i < args.length; i += 2) {
			String key = args[i];
			String value = args[i + 1];
			svnDumpTransformer.getReplacementMap().put(key, value);
		}

		svnDumpTransformer.transform();
	}

	public SvnDumpTransformer(File inputFile, File outputFile) {
		this.inputFile = inputFile;
		this.outputFile = outputFile;
	}

	public Map<String, String> getReplacementMap() {
		return replacementMap;
	}

	public void transform() throws IOException {
		System.out.println("Input:  " + inputFile.getAbsolutePath());
		System.out.println("Output: " + outputFile.getAbsolutePath());

		System.out.println("Transforming with the following replacement-map:");
		for (Map.Entry<String, String> me : replacementMap.entrySet()) {
			assertNotNull("replacementMap.entry.key", me.getKey());
			assertNotNull("replacementMap.entry.value", me.getValue());
			System.out.printf("  * \"%s\" => \"%s\"\n", me.getKey(), me.getValue());
		}
		System.out.println();

		try (ExtDataInputStream in = new ExtDataInputStream(new BufferedInputStream(new FileInputStream(inputFile)));) {
			this.in = in;
			try (ExtDataOutputStream out = new ExtDataOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile)));) {
				this.out = out;

				while (true) {
					ContentHeader contentHeader = readContentHeader();
					if (contentHeader == null)
						break;

					logContentHeaderRead(contentHeader);

					int contentLength = contentHeader.getContentLength(); // declared
					int contentLengthSum = 0; // counted ourselves from what we read (should match declared at the end!)

					int propContentLength = contentHeader.getPropContentLength();
					int textContentLength = contentHeader.getTextContentLength();

					PropContent propContent = null;
					if (propContentLength > 0) {
						propContent = readPropContent(propContentLength);
						contentLengthSum += propContentLength;
					}

					TextContent textContent = null;
					if (textContentLength > 0) {
						textContent = readTextContent(textContentLength);
						contentLengthSum += textContentLength;
					}

					if (contentLength > 0 && contentLength != contentLengthSum)
						throw new IOException(String.format("Declared content-length is %d, but read %d!", contentLength, contentLengthSum));


					ContentHeader newContentHeader = contentHeader.clone();
					transformContentHeader(contentHeader, newContentHeader);

					PropContent newPropContent = null;
					if (propContent != null) {
						newPropContent = propContent.clone();
						transformPropContent(contentHeader, newContentHeader, propContent, newPropContent);
					}

					TextContent newTextContent = null;
					if (textContent != null) {
						newTextContent = textContent.clone();
						transformTextContent(contentHeader, newContentHeader, propContent, newPropContent, textContent, newTextContent);
					}

					byte[] newPropContentData = null;
					if (newPropContent != null)
						newPropContentData = newPropContent.getData();

					byte[] newTextContentData = null;
					if (newTextContent != null)
						newTextContentData = newTextContent.getData();

					contentLengthSum = 0;
					boolean onlyHeader = true;

					if (newPropContentData != null) {
						newContentHeader.setPropContentLength(newPropContentData.length);
						contentLengthSum += newPropContentData.length;
						onlyHeader = false;
					}

					if (newTextContentData != null) {
						newContentHeader.setTextContentLength(newTextContentData.length);
						contentLengthSum += newTextContentData.length;
						onlyHeader = false;
					}

					if (! onlyHeader)
						newContentHeader.setContentLength(contentLengthSum);

					writeContentHeader(newContentHeader);

					if (newPropContentData != null)
						out.write(newPropContentData);

					if (newTextContentData != null)
						out.write(newTextContentData);
				}

				out.writeUtf8("\n");
				out.writeUtf8("\n");
			}
		}
	}

	private void transformContentHeader(ContentHeader contentHeader, ContentHeader newContentHeader) throws IOException {
		UUID uuid = newContentHeader.getUuid();
		if (uuid != null) {
			newContentHeader.setUuid(UUID.randomUUID());
			System.out.println("Switched to new UUID: " + newContentHeader.getUuid());
		}

		newContentHeader.getProperties().remove("Text-copy-source-md5");
		newContentHeader.getProperties().remove("Text-copy-source-sha1");
		newContentHeader.getProperties().remove("Text-content-md5");
		newContentHeader.getProperties().remove("Text-content-sha1");

		String path = transformString(contentHeader.getNodePath());
		if (path != null)
			newContentHeader.setNodePath(path);

		path = transformString(contentHeader.getNodeCopyFromPath());
		if (path != null)
			newContentHeader.setNodeCopyFromPath(path);
	}

	private void transformPropContent(ContentHeader contentHeader, ContentHeader newContentHeader, PropContent propContent, PropContent newPropContent) throws IOException {
		String string = transformString(newPropContent.getPropertyAsString("svn:log"));
		if (string != null)
			newPropContent.setProperty("svn:log", string);

		string = transformString(newPropContent.getPropertyAsString("svn:mergeinfo"));
		if (string != null)
			newPropContent.setProperty("svn:mergeinfo", string);
	}

	private void transformTextContent(ContentHeader contentHeader, ContentHeader newContentHeader, PropContent propContent, PropContent newPropContent, TextContent textContent, TextContent newTextContent) throws IOException {
		String mimeType = propContent == null ? null : propContent.getPropertyAsString("svn:mime-type");
		if ("application/octet-stream".equals(mimeType))
			return;

		if (mimeType != null)
			throw new IOException("Unexpected mime-type: " + mimeType);

		String text = new String(newTextContent.getData(), StandardCharsets.UTF_8);
		text = transformString(text);
		newTextContent.setData(text.getBytes(StandardCharsets.UTF_8));
	}

	private String transformString(String string) {
		if (string == null)
			return null;

		for (Map.Entry<String, String> me : replacementMap.entrySet()) {
			if (string.contains(me.getKey()))
				string = string.replaceAll(me.getKey(), me.getValue());
		}
		return string;
	}

	private void logContentHeaderRead(ContentHeader contentHeader) {
		int revisionNumber = contentHeader.getRevisionNumber();
		if (revisionNumber >= 0) {
			System.out.println();
			System.out.println("Read revisionNumber: " + revisionNumber);
			return;
		}

		String nodePath = contentHeader.getNodePath();
		if (nodePath != null) {
			System.out.println("Read node-path: " + nodePath);
			return;
		}

		UUID uuid = contentHeader.getUuid();
		if (uuid != null) {
			System.out.println("Read UUID: " + uuid);
			return;
		}
	}

	protected ContentHeader readContentHeader() throws IOException {
		ContentHeader header = new ContentHeader();
		String line;
		while (! in.isEof()) {
			in.mark(MEBIBYTE);
			line = in.readUtf8Line();
			if (isLineEmpty(line))
				header.setLeadingEmptyLineQty(header.getLeadingEmptyLineQty() + 1);
			else {
				in.reset();
				break;
			}
		};

		while (! in.isEof()) {
			line = in.readUtf8Line();
			if (! isLineEmpty(line))
				header.addPropertyFromLine(line);
			else
				break;
		}

		if (header.getProperties().isEmpty())
			return null;

		return header;
	}


	private void writeContentHeader(ContentHeader contentHeader) throws IOException {
		for (int i = 0; i < contentHeader.getLeadingEmptyLineQty(); ++i)
			out.writeUtf8("\n");

		for (Map.Entry<String, String> me : contentHeader.getProperties().entrySet()) {
			out.writeUtf8(me.getKey());
			out.writeUtf8(": "); // key/value separator
			out.writeUtf8(me.getValue());
			out.writeUtf8("\n"); // line separator!
		}

		// ended by 1 empty line!
		out.writeUtf8("\n");
	}

	private boolean isLineEmpty(String line) {
		return line.isEmpty() || line.equals("\n");
	}

	private PropContent readPropContent(int propContentLength) throws IOException {
		byte[] data = new byte[propContentLength];
		in.readFully(data);
		String text = new String(data, StandardCharsets.UTF_8);
		if (! text.endsWith("PROPS-END\n"))
			throw new IOException("PropContent misaligned?! text does not end with 'PROPS-END\n'!");

		PropContent propContent = new PropContent(data);
		return propContent;
	}

	private TextContent readTextContent(int textContentLength) throws IOException {
		byte[] data = new byte[textContentLength];
		in.readFully(data);
		in.mark(1);
		int followingByte = in.read();
		in.reset();

		if (followingByte != '\n')
			throw new IOException(String.format("Expected following byte to be %d, but found %d!", (int) '\n', followingByte));

		TextContent textContent = new TextContent();
		textContent.setData(data);
		return textContent;
	}
}
